shnitsel.data.shnitsel_db.db_function_decorator
===============================================

.. py:module:: shnitsel.data.shnitsel_db.db_function_decorator


Attributes
----------

.. autoapisummary::

   shnitsel.data.shnitsel_db.db_function_decorator.Param
   shnitsel.data.shnitsel_db.db_function_decorator.RetType
   shnitsel.data.shnitsel_db.db_function_decorator.T


Functions
---------

.. autoapisummary::

   shnitsel.data.shnitsel_db.db_function_decorator.add_as_tree_method
   shnitsel.data.shnitsel_db.db_function_decorator.concat_subtree
   shnitsel.data.shnitsel_db.db_function_decorator.layer_subtree
   shnitsel.data.shnitsel_db.db_function_decorator.list_subtree
   shnitsel.data.shnitsel_db.db_function_decorator.dataset_to_tree_method


Module Contents
---------------

.. py:data:: Param

.. py:data:: RetType

.. py:data:: T

.. py:function:: add_as_tree_method(cls = ShnitselDB)

   Decorator to add a function to the Tree/Database version of a shnitsel Dataset.

   If the function does not accept the tree-type argument as first argument, it can be transformed to support it with the decorator `dataset_to_tree_method`
   :param cls: The class to add the method to. Defaults to ShnitselDB.
   :type cls: type, optional

   :returns:

             Callable[
                 [Callable[Concatenate[T, Param], RetType]],
                 Callable[Concatenate[T, Param], RetType]
                 ]: Returns the function unchanged but adds it to the `cls` class as an instance method.


.. py:function:: concat_subtree(subtree, only_direct_children = False)

   Helper function to concatenate the trajectories in a subtree into a multi-trajetctory dataset.

   The resulting dataset has a new `frame` dimension along which we can iterate through all individual frames of all trajectories.

   :param subtree: The subtree of the ShnitselDB datastructure
   :type subtree: xr.DataTree
   :param only_direct: Whether to only gather trajectories from direct children of this subtree.
   :type only_direct: bool, optional

   :returns: The resulting multi-trajectory dataset
   :rtype: Trajectory


.. py:function:: layer_subtree(subtree, only_direct_children = False)

   Helper function to layer the trajectories in a subtree into a multi-trajetctory dataset.

   The new trajectory has a `trajid` dimension along which we can iterate through the different trajectories.
   Within trajectories, please check that you did not exceed the `time` dimension up to `max_ts` (which will be added as a variable) time steps or you will encounter NaN entries in most variables.

   :param subtree: The subtree of the ShnitselDB datastructure
   :type subtree: xr.DataTree
   :param only_direct: Whether to only gather trajectories from direct children of this subtree.
   :type only_direct: bool, optional

   :returns: The resulting multi-trajectory dataset
   :rtype: Trajectory


.. py:function:: list_subtree(subtree, only_direct_children = False)

   Helper function to collect the trajectories in a subtree into a trajectory list.

   :param subtree: The subtree of the ShnitselDB datastructure
   :type subtree: xr.DataTree
   :param only_direct: Whether to only gather trajectories from direct children of this subtree.
   :type only_direct: bool, optional

   :returns: The resulting trajectory list
   :rtype: List[Trajectory]


.. py:function:: dataset_to_tree_method(cls = ShnitselDB, aggregate_pre = None, aggregate_method_pre = None, aggregate_post = None, map_result_as_dict = False, unwrap_single_result = False, parallel = True)

   Decorator to add support for Tree/Database inputs when it originally only supports individual xr.Datasets.

   Automatically maps the function that applies to a dataset over the trajectories in the tree.
   Via additional arguments, you can specify, which kind of pre- and postprocessing should be performed on the database to support the function.

   :param cls: The class to add support for. Defaults to ShnitselDB.
   :type cls: type, optional
   :param aggregate_prior: Preprocessing method to apply. Option 1: specify the scope within which all trajectories should be aggregated, i.e.
                           "all": use all the trajectories in the set as base of inputs to the function,
                           "compound": use only the trajectories per compound group as base for input,
                           "group": use only the trajectories within the same Group as base for input.
                           altn). Defaults to None.
                           Option 2: Provide an explicit pre-processing function to turn the tree structure into a different tree with potentially fewer datasets.
                           Option 3: Perform no pre-processing by setting `None`.
                           Defaults to `None.
   :type aggregate_prior: Literal["all", "compound", "group"] | Callable[[cls], cls] | None, optional
   :param aggregate_post: Same semantics as for `aggregate_prior`, but now the aggregation is applied to the tree after applying the wrapped function to all trajectories. Defaults to None.
   :type aggregate_post: Literal["all", "compound", "group"] | Callable[[cls], cls] | None, optional
   :param unwrap_single_result: Whether a single result should be returned as the unwrapped value (True) or contained in the tree structure. Defaults to False.
   :type unwrap_single_result: bool, optional
   :param parallel: Whether application to different trajectories should occur in parallel. Defaults to True.
   :type parallel: bool, optional

   :returns:

             Callable[
                 [Callable[Concatenate[Trajectory, Param], RetType]],
                 Callable[Concatenate[Trajectory|T, Param], RetType]
                 ]: Returns a decorator that accepts a function with a trajectory as its first parameter and returns the function now supporting the cls type as a first parameter.


