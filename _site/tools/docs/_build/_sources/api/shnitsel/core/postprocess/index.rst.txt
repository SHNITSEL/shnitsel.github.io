shnitsel.core.postprocess
=========================

.. py:module:: shnitsel.core.postprocess


Attributes
----------

.. autoapisummary::

   shnitsel.core.postprocess.Astates
   shnitsel.core.postprocess.AtXYZ
   shnitsel.core.postprocess.DimName
   shnitsel.core.postprocess.Frames
   shnitsel.core.postprocess.PerState
   shnitsel.core.postprocess.InterState
   shnitsel.core.postprocess._var_delta_t_msg
   shnitsel.core.postprocess.convert_energy
   shnitsel.core.postprocess.convert_dipoles
   shnitsel.core.postprocess.convert_length


Classes
-------

.. autoapisummary::

   shnitsel.core.postprocess.Converter


Functions
---------

.. autoapisummary::

   shnitsel.core.postprocess.norm
   shnitsel.core.postprocess.subtract_combinations
   shnitsel.core.postprocess.pairwise_dists_pca
   shnitsel.core.postprocess.sudi
   shnitsel.core.postprocess.hop_indices
   shnitsel.core.postprocess.pca_and_hops
   shnitsel.core.postprocess.relativize
   shnitsel.core.postprocess.setup_frames
   shnitsel.core.postprocess.validate
   shnitsel.core.postprocess.ts_to_time
   shnitsel.core.postprocess.keep_norming
   shnitsel.core.postprocess._get_fosc
   shnitsel.core.postprocess.get_fosc
   shnitsel.core.postprocess.assign_fosc
   shnitsel.core.postprocess.broaden_gauss
   shnitsel.core.postprocess.ds_broaden_gauss
   shnitsel.core.postprocess.get_per_state
   shnitsel.core.postprocess.get_inter_state
   shnitsel.core.postprocess.calc_pops
   shnitsel.core.postprocess.calc_ci
   shnitsel.core.postprocess.ci_agg_last_dim
   shnitsel.core.postprocess.xr_calc_ci
   shnitsel.core.postprocess.time_grouped_ci
   shnitsel.core.postprocess.to_xyz
   shnitsel.core.postprocess.traj_to_xyz
   shnitsel.core.postprocess.dnorm
   shnitsel.core.postprocess.dcross
   shnitsel.core.postprocess.ddot
   shnitsel.core.postprocess.angle_
   shnitsel.core.postprocess.normal
   shnitsel.core.postprocess.dihedral_
   shnitsel.core.postprocess.full_dihedral_
   shnitsel.core.postprocess.dihedral
   shnitsel.core.postprocess.angle
   shnitsel.core.postprocess.distance
   shnitsel.core.postprocess.trajs_with_hops
   shnitsel.core.postprocess.get_hop_types
   shnitsel.core.postprocess.pick_statecombs
   shnitsel.core.postprocess.find_traj_hops
   shnitsel.core.postprocess.find_hops
   shnitsel.core.postprocess.set_atom_props
   shnitsel.core.postprocess.to_mol
   shnitsel.core.postprocess.mol_to_numbered_smiles
   shnitsel.core.postprocess.numbered_smiles_to_mol
   shnitsel.core.postprocess.default_mol


Module Contents
---------------

.. py:type:: Astates
   :canonical: xr.DataArray


.. py:type:: AtXYZ
   :canonical: xr.DataArray


.. py:type:: DimName
   :canonical: Hashable


.. py:type:: Frames
   :canonical: xr.Dataset


.. py:type:: PerState
   :canonical: xr.Dataset


.. py:type:: InterState
   :canonical: xr.Dataset


.. py:data:: _var_delta_t_msg
   :value: '`delta_t` varies between the trajectories. Please separate the trajectories into groups'


.. py:function:: norm(da, dim = 'direction', keep_attrs = None)

   Calculate the 2-norm of a DataArray, reducing the dimension with dame `dim`

   :param da: Array to calculate the norm of
   :param dim: Dimension to calculate norm along (and therby reduce), by default 'direction'
   :param optional: Dimension to calculate norm along (and therby reduce), by default 'direction'
   :param keep_attrs: How to deal with attributes; passed to xr.apply_ufunc, by default None
   :param optional: How to deal with attributes; passed to xr.apply_ufunc, by default None

   :rtype: A DataArray with dimension `dim` reduced


.. py:function:: subtract_combinations(da, dim, labels = False)

   Calculate all possible pairwise differences over a given dimension

   :param da: Input DataArray; must contain dimension `dim`
   :param dim: Dimension (of size $n$) to take pairwise differences over
   :param labels: If True, label the pairwise differences based on the index of `dim`, by default False
   :param optional: If True, label the pairwise differences based on the index of `dim`, by default False

   :rtype: A DataArray with the dimension `dim` replaced by a dimension '`dim`comb' of size $n(n-1)/2$


.. py:function:: pairwise_dists_pca(atXYZ, **kwargs)

   PCA-reduced pairwise interatomic distances

   :param atXYZ: A DataArray containing the atomic positions;
                 must have a dimension called 'atom'

   :returns: * A DataArray with the same dimensions as `atXYZ`, except for the 'atom'
             * *dimension, which is replaced by a dimension 'PC' containing the principal*
             * *components (by default 2)*


.. py:function:: sudi(da)

   Take successive differences along the 'frame' dimension

   :param da: An ``xarray.DataArray`` with a 'frame' dimension corresponding
              to a ``pandas.MultiIndex`` of which the innermost level is 'time'.

   :returns: * An ``xarray.DataArray`` with the same shape, dimension names etc.,
             * *but with the data of the (i)th frame replaced by the difference between*
             * *the original (i+1)th and (i)th frames, with zeros filling in for both the*
             * *initial frame and any frame for which time = 0, to avoid taking differences*
             * *between the last and first frames of successive trajectories.*


.. py:function:: hop_indices(astates)

   Find in which frames the active state changes

   :param astates: A DataArray of state indicators

   :rtype: A boolean DataArray indicating whether a hop took place


.. py:function:: pca_and_hops(frames)

   Get PCA points and info on which of them represent hops

   :param frames: A Dataset containing 'atXYZ' and 'astate' variables

   :returns: * *pca_res* -- The PCA-reduced pairwise interatomic distances
             * *hops_pca_coords* -- `pca_res` filtered by hops, to facilitate marking hops when plotting


.. py:function:: relativize(da, **sel)

.. py:function:: setup_frames(ds, *, to_time = None, convert_to_eV = None, convert_e_kin_to_eV = None, relativize_energy = None, relativize_selector=None)

   Performs several frequent setup tasks.
   Each task can be skipped (by setting the corresponding parameter to False),
   carried out if appropriate (None), or forced in the sense that an error is
   thrown if the task is redundant (True).


   :param ds: The frames-like xr.Dataset to setup.
   :param to_time: Whether to convert a 'ts' (timestep) coordinate to a 'time' coordinate, by default None
   :param optional: Whether to convert a 'ts' (timestep) coordinate to a 'time' coordinate, by default None
   :param convert_to_eV: Whether to convert the 'energy' variable to eV, by default None
   :param optional: Whether to convert the 'energy' variable to eV, by default None
   :param convert_e_kin_to_eV: Whether to convert the 'e_kin' (kinetic energy) variable to eV, by default None
   :param optional: Whether to convert the 'e_kin' (kinetic energy) variable to eV, by default None
   :param relativize_energy: Whether to relativize energies, by default None
   :param optional: Whether to relativize energies, by default None
   :param relativize_selector: This argument is passed to relativize, by default None
   :param optional: This argument is passed to relativize, by default None

   :rtype: A modified frames-like xr.Dataset

   :raises ValueError: If a task should be forced (i.e. the corresponding parameter is set to True)
       but cannot be carried out (e.g. because the dataset was already processed previously)


.. py:class:: Converter(quantity, conversions)

   .. py:attribute:: quantity


   .. py:attribute:: conversions


   .. py:attribute:: targets


   .. py:method:: __call__(da, to)


.. py:data:: convert_energy

.. py:data:: convert_dipoles

.. py:data:: convert_length

.. py:function:: validate(frames)

.. py:function:: ts_to_time(data, delta_t = None, old = 'drop')

.. py:function:: keep_norming(da, exclude = None)

.. py:function:: _get_fosc(energy, dip_trans)

.. py:function:: get_fosc(energy, dip_trans)

.. py:function:: assign_fosc(ds)

.. py:function:: broaden_gauss(E, fosc, agg_dim = 'frame', *, width = 0.5, nsamples = 1000, xmax = None)

   :param E: values used for the x-axis, presumably $E_i$
   :param fosc: values used for the y-axis, presumably $f_\mathrm{osc}$
   :param agg_dim: dimension along which to aggregate the many Gaussian distributions,
                   by default 'frame'
   :param optional: dimension along which to aggregate the many Gaussian distributions,
                    by default 'frame'
   :param width: the width (i.e. 2 standard deviations) of the Gaussian distributions
                 used, by default 0.001
   :param optional: the width (i.e. 2 standard deviations) of the Gaussian distributions
                    used, by default 0.001
   :param nsamples: number of evenly spaced x-values over which to sample the distribution,
                    by default 1000
   :param optional: number of evenly spaced x-values over which to sample the distribution,
                    by default 1000
   :param xmax: the maximum x-value, by default 3 standard deviations
                beyond the pre-broadened maximum
   :param optional: the maximum x-value, by default 3 standard deviations
                    beyond the pre-broadened maximum


.. py:function:: ds_broaden_gauss(ds, width = 0.5, nsamples = 1000, xmax = None)

.. py:function:: get_per_state(frames)

.. py:function:: get_inter_state(frames)

.. py:function:: calc_pops(frames)

   Fast way to calculate populations
   Requires states ids to be small integers


.. py:function:: calc_ci(a, confidence=0.95)

.. py:function:: ci_agg_last_dim(a, confidence=0.95)

.. py:function:: xr_calc_ci(a, dim, confidence = 0.95)

.. py:function:: time_grouped_ci(x, confidence = 0.9)

.. py:function:: to_xyz(da, comment='#')

.. py:function:: traj_to_xyz(traj_atXYZ)

.. py:function:: dnorm(a)

.. py:function:: dcross(a, b)

.. py:function:: ddot(a, b)

.. py:function:: angle_(a, b)

.. py:function:: normal(a, b, c)

.. py:function:: dihedral_(a, b, c, d)

.. py:function:: full_dihedral_(a, b, c, d)

.. py:function:: dihedral(atXYZ, i, j, k, l, *, deg = False, full = False)

   Calculate all dihedral angles between the atoms specified.
   The atoms specified needed be bonded.

   :param atXYZ: A ``DataArray`` of coordinates, with ``atom`` and ``direction`` dimensions
   :param i: The four atom indices
   :param j: The four atom indices
   :param k: The four atom indices
   :param l: The four atom indices
   :param deg: Whether to return angles in degrees (True) or radians (False), by default False
   :param full: Whether to return signed angles between -180° and 180° (True) or unsigned angles between 0 and 180° (False), by default False

   :rtype: A ``DataArray`` containing dihedral angles


.. py:function:: angle(atXYZ, i, j, k, *, deg = False)

.. py:function:: distance(atXYZ, i, j)

.. py:function:: trajs_with_hops(astates)

   Example usage: `trajs_with_hops(frames['astate'])`



.. py:function:: get_hop_types(astates)

   Example usage:



.. py:function:: pick_statecombs(da, statecombs, frames, framedim = 'frame')

.. py:function:: find_traj_hops(traj)

.. py:function:: find_hops(frames)

.. py:function:: set_atom_props(mol, **kws)

.. py:function:: to_mol(atXYZ_frame, charge=None, covFactor=1.2, to2D=True, molAtomMapNumber=None, atomNote=None, atomLabel=None)

.. py:function:: mol_to_numbered_smiles(mol)

.. py:function:: numbered_smiles_to_mol(smiles)

.. py:function:: default_mol(obj)

