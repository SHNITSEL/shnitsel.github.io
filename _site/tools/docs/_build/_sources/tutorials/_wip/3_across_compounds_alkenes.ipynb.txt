{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a5965ac5-04d1-4124-a895-61b1630c1e17",
   "metadata": {},
   "source": [
    "# Walktrough: Cross-Compound Analysis\n",
    "\n",
    "In this tutorial, we compare the **geometrical space explored during photoinduced dynamics** for related molecular systems: \n",
    "- the a Retinal system (**I02**)\n",
    "- and the compound **I01**, methyleneimmonium ($\\mathrm{CH_2NH_2^+}$)\n",
    "\n",
    "We demonstrate how to **select matching substructures** across different molecules in order to define **comparable, geometry-based descriptors**. These descriptors are then processed and analyzed using **principal component analysis (PCA)** to reduce the dimensionality from six internal coordinates to two, enabling clear and intuitive visualization of the sampled configuration space.\n",
    "\n",
    "> **Important**: \n",
    "> Note, the data of the tutorial is provided as a shnitsel-style NetCDF file for I02 (`./test_data/shnitsel/traj_I02.nc`) and imported from SHARC output files for I01 (`./test_data/sharc/traj_I01_v3.0_triplets/`) to illustrate that we can compare existing datasets to new datasets during analysis."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ed48b01a-61ca-49b0-aa11-bfe4b0948ac5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# from IPython.display import display\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import shnitsel as st\n",
    "import shnitsel.xarray"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9196b4a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "import logging\n",
    "logging.getLogger().setLevel(logging.DEBUG)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "32a558f2-8077-49c8-9561-830082f0e1b7",
   "metadata": {},
   "source": [
    "## 1) Loading and Annotating Molecular Trajectory Data\n",
    "\n",
    "In the first step, we load the trajectory data of methyleneimmonium (**I01**), retinal (**I02**):\n",
    "\n",
    "1. Read the trajectory datasets from disk.\n",
    "2. Clean the inputs to eliminate physically unreasonable data.\n",
    "3. Merge the data from the different compounds into a common tree that the further analysis will be based on"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "68af0e84",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.clean import sanity_check\n",
    "from shnitsel.data.tree.support_functions import tree_merge\n",
    "from pathlib import Path\n",
    "import xarray as xr\n",
    "\n",
    "alkenes_sources = {'A01': ('test_data/playground/alkenes/A01_ethene_stacked.nc', 0),\n",
    "                   'A02': ('test_data/playground/alkenes/A02_propene_stacked.nc', 0),\n",
    "                   'A03': ('test_data/playground/alkenes/A03_butene_stacked.nc', 0),\n",
    "                   'I01': ('test_data/playground/alkenes/I01_ch2nh2_stacked.nc', 1),\n",
    "                   }\n",
    "\n",
    "all_dt_in = []\n",
    "for name , (path, charge) in alkenes_sources.items():\n",
    "    print(f\"Loading {name}\")\n",
    "    dt_in = st.io.read(path=path).set_charge(charge).set_compound_info(name)\n",
    "    all_dt_in.append(dt_in)\n",
    "\n",
    "mc_dt_in = tree_merge(*all_dt_in)\n",
    "mc_dt_in"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e916df4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# all_dt_in[0][\"A01/0/data\"].indexes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ac401ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "all_dt_filtered = []\n",
    "for dt in all_dt_in:\n",
    "    all_dt_filtered.append(sanity_check(dt, geometry_thresholds={\"[*]~[*]\": 2.25, \"[#6,#7][#1]\":1.5}))\n",
    "\n",
    "mc_dt_filtered = tree_merge(*all_dt_filtered)\n",
    "mc_dt_filtered"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7ff4a9b5",
   "metadata": {},
   "outputs": [],
   "source": [
    "# mc_dt_filtered[\"A01/0/data\"].set_xindex(['atrajectory', 'time']).indexes"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "431ab5b1-1967-4579-9818-a46370f191aa",
   "metadata": {},
   "source": [
    "## 2) Computing Descriptors for common substructures\n",
    "\n",
    "In the next step, we **flag a common substructure** that all molecules share, namely the central double bond between an N and a C atom and the adjacent H atoms. This flagging identifies which substructure is considered in the subsequent analysis.\n",
    "\n",
    "### 2.1) Selecting a substructure\n",
    "\n",
    "There are two main strategies to select a substructure of interest for further processing:\n",
    "\n",
    "- provide a SMARTS string that fits the substructure in all compounds\n",
    "- identify the maximum common substructure automatically\n",
    "\n",
    "The following example will find the maximum common substructure shared between all compounds within the tree:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "21261419",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.bridges import to_mol\n",
    "from shnitsel.geo.analogs import extract_analogs\n",
    "analogs_tree = extract_analogs(mc_dt_filtered)\n",
    "assert analogs_tree is not None\n",
    "\n",
    "analogs_tree"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "94a821bf",
   "metadata": {},
   "source": [
    "We can also get a more in-detail look at the substructures identified by the analogs function:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ce067f14",
   "metadata": {},
   "outputs": [],
   "source": [
    "display(analogs_tree['A01/0/data'].mol)\n",
    "display(analogs_tree['A02/1/data'].mol)\n",
    "display(analogs_tree['A03/1/data'].mol)\n",
    "display(analogs_tree['I01/1/data'].mol)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "387d96a6",
   "metadata": {},
   "source": [
    "In fact, the matching has found the greatest possible overlap between the two molecules including the charge center around the nitrogen atom, its double bond to a neighboring C atom and the surrounding H atoms.\n",
    "\n",
    "In the following, we demonstrate how this selection would also have been possible by providing a SMARTS yourself:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a748b80d-939b-45d9-89c5-aa96b4de744b",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.geo.analogs import extract_analogs\n",
    "smarts_share = '[#6,#1][#6,#7]([#1])=[#6]([#1])[#6,#1]'# '[#1,#6][#6]([#1])=[#6,#7]([#1])[#1,#6]' \n",
    "analogs_tree = extract_analogs(mc_dt_filtered, smarts=smarts_share)\n",
    "display(analogs_tree['A01/0/data'].mol)\n",
    "display(analogs_tree['A02/1/data'].mol)\n",
    "display(analogs_tree['A03/1/data'].mol)\n",
    "display(analogs_tree['I01/1/data'].mol)\n",
    "analogs_tree"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49b46133-2204-4777-a4e9-814a97e91fea",
   "metadata": {},
   "source": [
    "### 2.2) Calculate descriptors\n",
    "\n",
    "Upon creating the dataset from the matching substructures of all compounds, we can now compute descriptors. Note, the atom numbering was adjusted, so that we can use descriptors that are sensitive to permutation. Since we only searched for 4 atoms in common, the bats, i.e. bonds, angles torsion would only yield 6 descriptors ($3\\cdot 4 - 6 = 6$). Similarly, there are 6 pairwise distances in the molecule ($\\frac{1}{2}\\cdot 4\\cdot(4-1) = 6$).\n",
    "\n",
    "One could apply the seperate functions `subtract_combinations`, `center`, and `norm` to obtain the pairwise distances, subtract the mean and normalize the features. This is also wrapped in a pipeline within the `get_standardized_pairwise_dists` function provided in `shnitsel.analyze.generic`, which we will use in the following. Note, we have to transpose the resulting array, as the PCA requires the data in shape (frames, descriptors).\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9b6d1bc6-78ee-4bd2-9115-08c8aff1be63",
   "metadata": {},
   "outputs": [],
   "source": [
    "# first we perform PCA over pairwise distances for the whole A03 molecule\n",
    "from shnitsel.vis.plot import biplot_kde\n",
    "from shnitsel.analyze.pca import PCA\n",
    "\n",
    "I01_analog_stacked = analogs_tree[\"I01/1/data\"]#.stacked\n",
    "I01_analog_stacked.mol"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb950770",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.geo.geocalc import get_bats\n",
    "\n",
    "selection_keys = ['bonds', 'angles', 'dihedrals']\n",
    "# Calculate all BATs for all analogs:\n",
    "dt_analog_bats_all = get_bats(analogs_tree, selection_keys)\n",
    "\n",
    "# Calculate the PCA for all analogs\n",
    "pca_res = PCA(analogs_tree, structure_selection=selection_keys)\n",
    "\n",
    "#Since we provided the inputs as a tree, the result is also a tree: \n",
    "pca_res\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2aa62dac",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We can obtain a single PCA result: \n",
    "pca_res_I01_unwrapped =  pca_res[\"I01/pca\"].data\n",
    "# And take a look at the most impactful features identified by PCA:\n",
    "display(I01_analog_stacked.mol)\n",
    "print(pca_res_I01_unwrapped.explain_loadings())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "09f25fd2",
   "metadata": {},
   "source": [
    "We note that the dihedral `(0,1,2,3)` seems to be the most significant impact on the PCA result, so let us visualize the results with color coding to observe the impact of that dihedral across all analogs:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6fc9dab",
   "metadata": {},
   "outputs": [],
   "source": [
    "kde_data = biplot_kde(\n",
    "    analogs_tree, 0, 1, 2, 3, pca_data=pca_res, num_bins=4, scatter_color_property=\"geo\"\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0806555-685d-4593-ac63-cb065009d196",
   "metadata": {},
   "source": [
    "## 3) Compare Compounds\n",
    "\n",
    "Let us project the different compounds to a common component representation, e.g. the A02 representation:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "80ccaa52",
   "metadata": {},
   "outputs": [],
   "source": [
    "reference_pca = pca_res[\"A03/pca\"].data\n",
    "\n",
    "# Project all features onto the principal components for I01\n",
    "# The pca result offers the function `.project_array` to project an arbitrary array onto the results of the PCA pipeline\n",
    "\n",
    "# We\n",
    "mc_projected_features = dt_analog_bats_all.map_data(reference_pca.project_array)\n",
    "mc_projected_features"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "90d5942b",
   "metadata": {},
   "source": [
    "Let us visualize the PC space exploration for the different compounds:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0159867e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.vis.colormaps import st_blue, st_grey, st_yellow, st_violet, st_orange\n",
    "from shnitsel.analyze.hops import filter_data_at_hops\n",
    "\n",
    "compound_colors = {\"A01\": st_grey, \"A02\": st_yellow, \"A03\": st_violet, \"I01\":st_blue}\n",
    "\n",
    "fig, axs = plt.subplot_mosaic([['A01', 'A02'],['A03', 'I01'],], layout='constrained')\n",
    "for ax_name, ax in axs.items():\n",
    "    ax.set_title(ax_name)\n",
    "    for compound_name, data in mc_projected_features.compounds.items():\n",
    "        stacked_data =  data.as_stacked\n",
    "        ax.plot(stacked_data.isel(PC=0), stacked_data.isel(PC=1), c='#ccc', rasterized=True)\n",
    "\n",
    "    compound_data = mc_projected_features[ax_name].as_stacked    \n",
    "\n",
    "    compound_color = compound_colors[ax_name]\n",
    "\n",
    "    ax.plot(compound_data.isel(PC=0), compound_data.isel(PC=1), c=compound_color, rasterized=True)\n",
    "\n",
    "    hops_positions_21 = filter_data_at_hops(compound_data, \"2->1\")\n",
    "    hops_positions_32 = filter_data_at_hops(compound_data, \"3->2\")\n",
    "    ax.scatter(hops_positions_21.isel(PC=0), hops_positions_21.isel(PC=1), c=st_orange, s=1, zorder=10, rasterized=True)\n",
    "    ax.scatter(hops_positions_32.isel(PC=0), hops_positions_32.isel(PC=1), c='#0D6F71', s=1, zorder=10, rasterized=True)\n",
    "    \n",
    "fig.supxlabel('PC1')\n",
    "fig.supylabel('PC2')\n",
    "fig.savefig(\"./PCA_across_compounds_A01_A02_A03_I01_proj_A03.pdf\", dpi=300)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "856b9f16",
   "metadata": {},
   "source": [
    "We can first off all see the different degree of phase space exploration in the second principal component coordinate but also, interestingly, a significant difference in the location of phase transitions. \n",
    "`2->1` phase transitions are very clearly centered around the `PC2=0.0` line, with only some ouliers for `A01`, but the distribution of `3->2` tansitions is very different for the various compounds. \n",
    "- `A01` has some of those `3->2` transitions, all gathered around `PC1=0.0`, i.e. at smaller dihedrals\n",
    "- `I01` has those transitions accumulated in `PC1<0`, i.e. at high dihedral angles.\n",
    "- `A02` and `A03` have those transitions only rarely and then centered around `PC1=0.0` like `A01`.\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "86aa91f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.analyze.generic import pwdists\n",
    "from shnitsel.geo.analogs import extract_analogs\n",
    "smarts_share = '[#6,#1][#6,#7]([#1])=[#6]([#1])[#6,#1]'#'[#1,#6][#6]=[#6,#7][#1,#6]'\n",
    "analogs_tree = extract_analogs(mc_dt_filtered, smarts=smarts_share)\n",
    "display(analogs_tree['A01/0/data'].mol)\n",
    "display(analogs_tree['A02/1/data'].mol)\n",
    "display(analogs_tree['A03/1/data'].mol)\n",
    "display(analogs_tree['I01/1/data'].mol)\n",
    "analogs_tree\n",
    "\n",
    "selection_keys = None\n",
    "# Calculate all BATs for all analogs:\n",
    "dt_analog_bats_all = analogs_tree.map_data(pwdists)\n",
    "# Calculate the PCA for all analogs\n",
    "pca_res = PCA(analogs_tree, structure_selection=selection_keys)\n",
    "\n",
    "# We can obtain a single PCA result: \n",
    "pca_res_I01_unwrapped =  pca_res[\"I01/pca\"].data\n",
    "# And take a look at the most impactful features identified by PCA:\n",
    "kde_data = biplot_kde(\n",
    "    analogs_tree, 0, 1, 2, 3, pca_data=pca_res, num_bins=4, scatter_color_property=\"geo\"\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5a7aba3f",
   "metadata": {},
   "outputs": [],
   "source": [
    "reference_pca = pca_res[\"A03/pca\"].data\n",
    "\n",
    "# Project all features onto the principal components for I01\n",
    "# The pca result offers the function `.project_array` to project an arbitrary array onto the results of the PCA pipeline\n",
    "\n",
    "# We\n",
    "mc_projected_features = dt_analog_bats_all.map_data(reference_pca.project_array)\n",
    "mc_projected_features"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a96216ab",
   "metadata": {},
   "outputs": [],
   "source": [
    "from shnitsel.vis.colormaps import st_blue, st_grey, st_yellow, st_violet, st_orange\n",
    "from shnitsel.analyze.hops import filter_data_at_hops\n",
    "\n",
    "compound_colors = {\"A01\": st_grey, \"A02\": st_yellow, \"A03\": st_violet, \"I01\":st_blue}\n",
    "\n",
    "fig, axs = plt.subplot_mosaic([['A01', 'A02'],['A03', 'I01'],], layout='constrained')\n",
    "for ax_name, ax in axs.items():\n",
    "    ax.set_title(ax_name)\n",
    "    for compound_name, data in mc_projected_features.compounds.items():\n",
    "        stacked_data =  data.as_stacked\n",
    "        ax.plot(stacked_data.isel(PC=0), stacked_data.isel(PC=1), c='#ccc', rasterized=True)\n",
    "\n",
    "    compound_data = mc_projected_features[ax_name].as_stacked    \n",
    "\n",
    "    compound_color = compound_colors[ax_name]\n",
    "\n",
    "    ax.plot(compound_data.isel(PC=0), compound_data.isel(PC=1), c=compound_color, rasterized=True)\n",
    "\n",
    "    hops_positions_21 = filter_data_at_hops(compound_data, \"2->1\")\n",
    "    hops_positions_32 = filter_data_at_hops(compound_data, \"3->2\")\n",
    "    ax.scatter(hops_positions_21.isel(PC=0), hops_positions_21.isel(PC=1), c=st_orange, s=1, zorder=10, rasterized=True)\n",
    "    ax.scatter(hops_positions_32.isel(PC=0), hops_positions_32.isel(PC=1), c='#0D6F71', s=1, zorder=10, rasterized=True)\n",
    "    \n",
    "fig.supxlabel('PC1')\n",
    "fig.supylabel('PC2')\n",
    "fig.savefig(\"./PCA_across_compounds_pwdist_A01_A02_A03_I01_proj_A03.pdf\", dpi=300)\n",
    "fig.savefig(\"./PCA_across_compounds_pwdist_A01_A02_A03_I01_proj_A03.png\", dpi=300)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "shnitsel-tools-official (3.12.3)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
